<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hotbot - Plataforma de Gestão</title>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/reactflow@11/dist/umd/index.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <link href="https://unpkg.com/reactflow@11/dist/style.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

  <style>
    :root {
      --bg-dark: #111827; --bg-light: #1f2937; --bg-lighter: #374151; --border-color: #4b5563;
      --text-light: #f9fafb; --text-dark: #9ca3af; --primary: #818cf8; --primary-dark: #6366f1;
      --danger: #f43f5e; --success: #22c55e; --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html,body,#root { height: 100%; font-family: var(--font-sans); }
    body { background: var(--bg-dark); color: var(--text-light); -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    .app-container { display: flex; height: 100vh; }
    .sidebar { width: 240px; background: var(--bg-dark); border-right: 1px solid var(--border-color); padding: 1.5rem; display: flex; flex-direction: column; transition: width 0.3s; }
    .sidebar h1 { font-size: 1.5rem; font-weight: 700; margin-bottom: 2.5rem; color: var(--primary); }
    .nav-menu { display: flex; flex-direction: column; gap: 0.75rem; }
    .nav-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 1rem; border-radius: 0.5rem; cursor: pointer; font-weight: 500; transition: background 0.2s, color 0.2s; }
    .nav-item:hover { background: var(--bg-light); }
    .nav-item.active { background: var(--primary); color: white; box-shadow: 0 4px 14px 0 rgba(99, 102, 241, 0.5); }
    .sidebar .logout-btn { margin-top: auto; background: var(--danger); }
    .main-content { flex: 1; padding: 2.5rem; overflow-y: auto; }
    .page-header { font-size: 1.75rem; font-weight: bold; margin-bottom: 2rem; }
    .card { background: var(--bg-light); padding: 1.5rem; border-radius: 0.75rem; border: 1px solid var(--border-color); box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); }
    .form-group { margin-bottom: 1.25rem; }
    .form-group label { display: block; margin-bottom: 0.5rem; font-weight: 500; color: var(--text-dark); }
    .form-input, .form-select, .form-textarea { width: 100%; padding: 0.75rem 1rem; border-radius: 0.5rem; border: 1px solid var(--border-color); background: var(--bg-dark); color: var(--text-light); font-size: 1rem; transition: border-color 0.2s, box-shadow 0.2s; }
    .form-input:focus, .form-select:focus, .form-textarea:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 2px var(--primary-dark); }
    .btn { display: inline-flex; align-items: center; gap: 0.5rem; padding: 0.75rem 1.5rem; border-radius: 0.5rem; border: none; cursor: pointer; font-weight: bold; transition: background 0.2s, transform 0.1s; }
    .btn:hover { transform: translateY(-1px); }
    .btn-primary { background: linear-gradient(to right, var(--primary), var(--primary-dark)); color: white; }
    .btn-danger { background: var(--danger); color: white; }
    .btn-secondary { background: var(--bg-lighter); color: white; }
    .btn-sm { padding: 0.5rem 1rem; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 1.5rem; }
    .flow-card { display: flex; flex-direction: column; justify-content: space-between; height: 160px; transition: transform 0.2s, box-shadow 0.2s; }
    .flow-card:hover { transform: translateY(-4px); box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); }
    .flow-card h3 { font-size: 1.2rem; }
    .bot-item, .user-item { display: flex; justify-content: space-between; align-items: center; padding: 1rem; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
    .user-item-info { display: flex; flex-direction: column; }
    .user-item-name { font-weight: bold; }
    .user-item-id { font-size: 0.8rem; color: var(--text-dark); }
    .chat-layout { display: flex; height: calc(100vh - 10rem); background: var(--bg-dark); border-radius: 0.75rem; }
    .user-list { width: 300px; border-right: 1px solid var(--border-color); overflow-y: auto; }
    .user-list .user-item:hover { background-color: var(--bg-light); }
    .user-list .user-item[data-active='true'] { background-color: var(--primary); color: white; }
    .chat-window { flex: 1; display: flex; flex-direction: column; }
    .message-list { flex: 1; padding: 1.5rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.75rem; }
    .message { padding: 0.75rem 1rem; border-radius: 1rem; max-width: 75%; line-height: 1.5; }
    .message.user { background: var(--bg-lighter); align-self: flex-start; border-bottom-left-radius: 0.25rem; }
    .message.operator, .message.bot { background: var(--primary-dark); align-self: flex-end; border-bottom-right-radius: 0.25rem; color: white; }
    .login-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 100; backdrop-filter: blur(5px); }
    .login-box { background: var(--bg-light); padding: 2.5rem; border-radius: 0.75rem; width: 380px; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); }
    .flow-editor-page { height: 100vh; }
    .react-flow__node-trigger { background: #dbeafe; border-color: #60a5fa; cursor: default !important; }
    .react-flow__node-message { background: #dcfce7; border-color: #4ade80; }
    .react-flow__node-action_pix { background: #fef9c3; border-color: #facc15; }
    .react-flow__node-action_city { background: #cffafe; border-color: #22d3ee; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useCallback, useEffect, useRef, memo } = React;
    const { ReactFlowProvider, ReactFlow, useNodesState, useEdgesState, addEdge, Background, Controls, Handle, Position } = window.ReactFlow;
    const API_BASE_URL = 'https://novaapi-one.vercel.app/api';

    const api = axios.create({ baseURL: API_BASE_URL });
    api.interceptors.request.use(config => {
      const token = localStorage.getItem('authToken');
      if (token) config.headers.Authorization = `Bearer ${token}`;
      return config;
    });

    function App() {
      const [isAuthenticated, setIsAuthenticated] = useState(!!localStorage.getItem('authToken'));
      const [currentPage, setCurrentPage] = useState('bots');
      const [editingFlow, setEditingFlow] = useState(null);

      const handleLogin = (token) => {
        localStorage.setItem('authToken', token);
        setIsAuthenticated(true);
      };

      const handleLogout = () => {
        localStorage.removeItem('authToken');
        setIsAuthenticated(false);
      };

      const navigateToFlowEditor = (flow) => {
        setEditingFlow(flow);
        setCurrentPage('flow-editor');
      };

      if (!isAuthenticated) return <LoginScreen onLogin={handleLogin} />;

      return (
        <div className="app-container">
          {currentPage !== 'flow-editor' && <Sidebar currentPage={currentPage} setCurrentPage={setCurrentPage} onLogout={handleLogout} />}
          <main className={currentPage !== 'flow-editor' ? "main-content" : ''} style={{padding: currentPage === 'flow-editor' ? 0 : '2.5rem', height: '100vh', width: '100%'}}>
            {currentPage === 'bots' && <BotsPage />}
            {currentPage === 'flows' && <FlowsListPage onEditFlow={navigateToFlowEditor} />}
            {currentPage === 'chat' && <LiveChatPage />}
            {currentPage === 'disparos' && <DisparosPage />}
            {currentPage === 'flow-editor' && <FlowEditorPage flow={editingFlow} onBack={() => setCurrentPage('flows')} />}
          </main>
        </div>
      );
    }
    
    function Sidebar({ currentPage, setCurrentPage, onLogout }) {
        const pages = { bots: '🤖 Bots', flows: '🌊 Fluxos', chat: '💬 Chat ao Vivo', disparos: '🚀 Disparos' };
        return (
            <aside className="sidebar">
                <h1>Hotbot</h1>
                <nav className="nav-menu">
                    {Object.entries(pages).map(([key, value]) => (
                        <div key={key} className={`nav-item ${currentPage === key ? 'active' : ''}`} onClick={() => setCurrentPage(key)}>
                            <i className={`fa-solid fa-${value.split(' ')[0]}`}></i>
                            <span>{value.split(' ').slice(1).join(' ')}</span>
                        </div>
                    ))}
                </nav>
                <button className="btn logout-btn" onClick={onLogout}><i className="fa-solid fa-right-from-bracket"></i> Sair</button>
            </aside>
        );
    }

    function BotsPage() {
      const [bots, setBots] = useState([]);
      const [newBotName, setNewBotName] = useState('');

      const fetchBots = async () => {
        try {
          const response = await api.get('/dashboard/data');
          setBots(response.data.bots || []);
        } catch (error) { console.error("Erro ao buscar bots:", error); }
      };

      useEffect(() => { fetchBots(); }, []);

      const handleCreateBot = async (e) => {
        e.preventDefault();
        if (!newBotName) return;
        try {
          await api.post('/bots', { bot_name: newBotName });
          setNewBotName('');
          fetchBots();
        } catch (error) { alert('Erro ao criar bot: ' + error.response?.data?.message); }
      };

      const handleDeleteBot = async (botId) => {
        if (confirm('Tem certeza que deseja excluir este bot?')) {
          try {
            await api.delete(`/bots/${botId}`);
            fetchBots();
          } catch (error) { alert('Erro ao excluir bot.'); }
        }
      };
      
      const handleUpdateToken = async (botId) => {
        const token = prompt("Digite o novo token do Telegram para este bot:");
        if (token) {
            try {
                await api.put(`/bots/${botId}`, { bot_token: token });
                alert("Token atualizado com sucesso!");
                fetchBots();
            } catch (error) {
                alert('Erro ao atualizar token: ' + error.response?.data?.message);
            }
        }
      };

      const handleSetWebhook = async (botId) => {
          try {
              const response = await api.post(`/bots/${botId}/set-webhook`);
              alert(response.data.message);
          } catch (error) {
              console.error("Erro detalhado ao configurar webhook:", error);
              let errorMessage = "Ocorreu um erro desconhecido.";
              if (error.response) {
                  errorMessage = error.response.data?.message || `Erro ${error.response.status}`;
              } else if (error.request) {
                  errorMessage = "Não foi possível conectar ao servidor.";
              } else {
                  errorMessage = error.message;
              }
              alert('Falha ao configurar Webhook: ' + errorMessage);
          }
      };

      return (
        <>
          <h2 className="page-header">Gerenciar Bots</h2>
          <div className="card" style={{ marginBottom: '1.5rem' }}>
            <h3><i className="fa-solid fa-plus" style={{marginRight: '0.5rem'}}></i>Adicionar Novo Bot</h3>
            <form onSubmit={handleCreateBot}>
              <div className="form-group">
                <label htmlFor="botName">Nome de usuário do Bot</label>
                <input id="botName" className="form-input" value={newBotName} onChange={(e) => setNewBotName(e.target.value)} placeholder="@meu_bot_telegram" />
              </div>
              <button className="btn btn-primary" type="submit"><i className="fa-solid fa-robot"></i> Criar Bot</button>
            </form>
          </div>
          <div className="card">
            <h3><i className="fa-solid fa-list-check" style={{marginRight: '0.5rem'}}></i>Bots Existentes</h3>
            {bots.map(bot => (
              <div key={bot.id} className="bot-item">
                <span>{bot.bot_name}</span>
                <div style={{display: 'flex', gap: '0.5rem'}}>
                  <button className="btn btn-secondary btn-sm" onClick={() => handleSetWebhook(bot.id)}><i className="fa-solid fa-link"></i> Webhook</button>
                  <button className="btn btn-secondary btn-sm" onClick={() => handleUpdateToken(bot.id)}><i className="fa-solid fa-key"></i> Token</button>
                  <button className="btn btn-danger btn-sm" onClick={() => handleDeleteBot(bot.id)}><i className="fa-solid fa-trash"></i></button>
                </div>
              </div>
            ))}
          </div>
        </>
      );
    }

    function FlowsListPage({ onEditFlow }) {
        const [bots, setBots] = useState([]);
        const [selectedBotId, setSelectedBotId] = useState('');
        const [flows, setFlows] = useState([]);

        useEffect(() => {
            const fetchBots = async () => {
                const response = await api.get('/dashboard/data');
                setBots(response.data.bots || []);
                if(response.data.bots.length > 0) setSelectedBotId(response.data.bots[0].id);
            };
            fetchBots();
        }, []);

        const fetchFlows = useCallback(async () => {
            if (!selectedBotId) { setFlows([]); return; }
            try {
                const response = await api.get('/flows');
                setFlows(response.data.filter(f => f.bot_id == selectedBotId));
            } catch (error) { console.error("Erro ao buscar fluxos:", error); }
        }, [selectedBotId]);
        
        useEffect(() => { fetchFlows() }, [fetchFlows]);

        const handleCreateFlow = async () => {
            const name = prompt("Nome do novo fluxo:");
            if(name && selectedBotId) {
                await api.post('/flows', { name, botId: selectedBotId });
                fetchFlows();
            }
        };

        const handleDeleteFlow = async (flowId) => {
            if (confirm("Tem certeza que deseja excluir este fluxo?")) {
                try {
                    await api.delete(`/flows/${flowId}`);
                    fetchFlows();
                } catch (error) {
                     alert('Erro ao deletar fluxo.');
                }
            }
        };

        return (
            <>
                <h2 className="page-header">Fluxos de Conversa</h2>
                <div className="card" style={{padding: '1rem 1.5rem', marginBottom: '1.5rem', display: 'flex', alignItems: 'center', justifyContent: 'space-between'}}>
                    <div className="form-group" style={{flex: 1, marginBottom: 0}}>
                        <label htmlFor="botSelect">Selecione um Bot</label>
                        <select id="botSelect" className="form-select" value={selectedBotId} onChange={e => setSelectedBotId(e.target.value)}>
                             <option value="">-- Selecione --</option>
                            {bots.map(b => <option key={b.id} value={b.id}>{b.bot_name}</option>)}
                        </select>
                    </div>
                    <button className="btn btn-primary" style={{marginLeft: '1rem'}} onClick={handleCreateFlow} disabled={!selectedBotId}><i className="fa-solid fa-plus"></i> Novo Fluxo</button>
                </div>
                <div className="grid">
                    {flows.map(flow => (
                        <div key={flow.id} className="card flow-card">
                            <h3>{flow.name}</h3>
                            <div style={{display: 'flex', gap: '0.5rem'}}>
                                <button className="btn btn-primary btn-sm" onClick={() => onEditFlow(flow)}><i className="fa-solid fa-diagram-project"></i> Abrir Editor</button>
                                <button className="btn btn-danger btn-sm" onClick={() => handleDeleteFlow(flow.id)}><i className="fa-solid fa-trash"></i></button>
                            </div>
                        </div>
                    ))}
                </div>
            </>
        );
    }
    
    function DisparosPage() {
        const [bots, setBots] = useState([]);
        const [selectedBotIds, setSelectedBotIds] = useState([]);
        const [message, setMessage] = useState('');

        useEffect(() => {
            const fetchBots = async () => {
                const { data } = await api.get('/dashboard/data');
                setBots(data.bots || []);
            };
            fetchBots();
        }, []);

        const handleSend = async () => {
            if (selectedBotIds.length === 0 || !message) {
                alert("Selecione ao menos um bot e digite uma mensagem.");
                return;
            }
            try {
                await api.post('/bots/mass-send', { botIds, initialText: message, ctaButtonText: "Saber mais", externalLink: "https://google.com" });
                alert("Disparo agendado com sucesso!");
                setMessage('');
            } catch (error) { alert("Erro ao enviar disparo."); }
        };

        const handleBotSelection = (botId) => {
            setSelectedBotIds(prev => prev.includes(botId) ? prev.filter(id => id !== botId) : [...prev, botId]);
        };

        return (
            <>
                <h2 className="page-header">Disparos em Massa</h2>
                <div className="card">
                    <div className="form-group">
                        <label>Selecione os Bots de Destino</label>
                        {bots.map(bot => (
                            <div key={bot.id} style={{display: 'flex', alignItems: 'center', gap: '0.5rem', marginBottom: '0.5rem'}}>
                                <input type="checkbox" id={`bot-${bot.id}`} checked={selectedBotIds.includes(bot.id)} onChange={() => handleBotSelection(bot.id)} style={{width: '1rem', height: '1rem'}}/>
                                <label htmlFor={`bot-${bot.id}`}>{bot.bot_name}</label>
                            </div>
                        ))}
                    </div>
                    <div className="form-group">
                        <label htmlFor="message">Mensagem</label>
                        <textarea id="message" className="form-textarea" rows="5" value={message} onChange={e => setMessage(e.target.value)}></textarea>
                    </div>
                    <button className="btn btn-primary" onClick={handleSend}><i className="fa-solid fa-paper-plane"></i> Enviar Disparo</button>
                </div>
            </>
        );
    }

    function LiveChatPage() {
        const [bots, setBots] = useState([]);
        const [selectedBotId, setSelectedBotId] = useState('');
        const [users, setUsers] = useState([]);
        const [selectedChatId, setSelectedChatId] = useState('');
        const [messages, setMessages] = useState([]);
        const [newMessage, setNewMessage] = useState('');
        const messagesEndRef = useRef(null);

        useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }); }, [messages]);
        
        useEffect(() => {
            const fetchBots = async () => {
                const { data } = await api.get('/dashboard/data');
                setBots(data.bots || []);
                if (data.bots.length > 0) setSelectedBotId(data.bots[0].id);
            };
            fetchBots();
        }, []);

        const fetchUsers = useCallback(async () => {
            if (!selectedBotId) return;
            setUsers([]); setMessages([]); setSelectedChatId('');
            try {
                const { data } = await api.get(`/chats/${selectedBotId}`);
                setUsers(data);
            } catch (error) { console.error("Erro ao buscar usuários", error); }
        }, [selectedBotId]);
        
        useEffect(() => { fetchUsers() }, [fetchUsers]);

        const fetchMessages = useCallback(async () => {
            if (!selectedBotId || !selectedChatId) return;
            try {
                const { data } = await api.get(`/chats/${selectedBotId}/${selectedChatId}`);
                setMessages(data);
            } catch (error) { console.error("Erro ao buscar mensagens", error); setMessages([]); }
        }, [selectedBotId, selectedChatId]);
        
        useEffect(() => {
            fetchMessages();
            const interval = setInterval(fetchMessages, 3000); // <-- ATUALIZAÇÃO AUTOMÁTICA
            return () => clearInterval(interval);
        }, [fetchMessages]);
        
        const handleSendMessage = async (e) => {
            e.preventDefault();
            const textToSend = newMessage.trim();
            if (!textToSend || !selectedChatId || !selectedBotId) return;

            const optimisticMessage = { message_id: Date.now(), first_name: "Você", last_name: "(Operador)", message_text: textToSend, sender_type: 'operator', created_at: new Date().toISOString() };
            setMessages(prev => [...prev, optimisticMessage]);
            setNewMessage('');
            try {
                await api.post(`/chats/${selectedBotId}/send-message`, { chatId: selectedChatId, text: textToSend });
                fetchMessages();
            } catch (error) {
                console.error("Erro ao enviar mensagem:", error);
                setMessages(prev => prev.filter(m => m.message_id !== optimisticMessage.message_id));
            }
        };
        
        const handleDeleteConversation = async (chatIdToDelete) => {
            if (confirm(`Tem certeza que deseja excluir toda a conversa deste lead?`)) {
                try {
                    await api.delete(`/chats/${selectedBotId}/${chatIdToDelete}`);
                    alert('Conversa excluída com sucesso!');
                    fetchUsers();
                    if (selectedChatId === chatIdToDelete) { setSelectedChatId(''); setMessages([]); }
                } catch (error) { alert('Erro ao excluir a conversa.'); }
            }
        };

        return (
            <>
                <h2 className="page-header">Chat ao Vivo</h2>
                <div className="form-group">
                    <select className="form-select" value={selectedBotId} onChange={e => setSelectedBotId(e.target.value)}>
                        <option value="">-- Selecione um Bot --</option>
                        {bots.map(b => <option key={b.id} value={b.id}>{b.bot_name}</option>)}
                    </select>
                </div>
                <div className="card chat-layout">
                    <div className="user-list">
                        {users.map(user => (
                            <div key={user.chat_id} className="user-item" data-active={selectedChatId === user.chat_id} onClick={() => setSelectedChatId(user.chat_id)} style={{cursor:'pointer'}}>
                                <div className="user-item-info">
                                    <span className="user-item-name">{user.click_id || `${user.first_name} ${user.last_name || ''}`}</span>
                                    <span className="user-item-id">ID: {user.chat_id}</span>
                                </div>
                                <button className="btn btn-danger btn-sm" onClick={(e) => { e.stopPropagation(); handleDeleteConversation(user.chat_id); }}><i className="fa-solid fa-trash"></i></button>
                            </div>
                        ))}
                    </div>
                    <div className="chat-window">
                        <div className="message-list">
                            {messages.map((msg, index) => (
                                <div key={msg.message_id || index} className={`message ${msg.sender_type === 'operator' ? 'operator' : msg.sender_type === 'bot' ? 'bot' : 'user'}`}>
                                    <strong>{msg.sender_type === 'user' ? (msg.first_name + ' ' + (msg.last_name || '')) : (msg.last_name === '(Fluxo)' ? `🤖 ${msg.first_name}` : `👤 ${msg.first_name} ${msg.last_name || ''}`)}:</strong><br/>
                                    {msg.message_text}
                                </div>
                            ))}
                            <div ref={messagesEndRef} />
                        </div>
                        {selectedChatId && (
                             <form onSubmit={handleSendMessage} style={{display: 'flex', padding: '1rem', borderTop: '1px solid var(--border-color)'}}>
                                <input className="form-input" value={newMessage} onChange={e => setNewMessage(e.target.value)} placeholder="Digite sua resposta..." />
                                <button className="btn btn-primary" type="submit" style={{marginLeft: '0.5rem'}}><i className="fa-solid fa-paper-plane"></i> Enviar</button>
                            </form>
                        )}
                    </div>
                </div>
            </>
        );
    }
    
    // --- Flow Editor Components ---
    const initialNodes = [{ id: 'start', type: 'trigger', position: { x: 250, y: 50 }, data: {} }];
    
    const nodeTypes = {
        trigger: memo(({ data }) => (
            <>
                <div><strong>🚀 Gatilho</strong></div>
                <p style={{fontSize: 12, color: '#555'}}>Novo contato via Telegram</p>
                <Handle type="source" position={Position.Bottom} />
            </>
        )),
        message: memo(({ data }) => (
            <>
                <Handle type="target" position={Position.Top} />
                <div><strong>💬 Mensagem</strong></div>
                <p style={{'whiteSpace': 'pre-wrap'}}>{data.text || 'Clique para editar'}</p>
                <Handle type="source" position={Position.Bottom} />
            </>
        )),
        action_pix: memo(({ data }) => (
            <>
                <Handle type="target" position={Position.Top} />
                <div><strong>💳 Gerar PIX (Ação)</strong></div>
                <p>Valor: R$ {((data.valueInCents || 0) / 100).toFixed(2)}</p>
                <small style={{fontSize: 12, color: '#555'}}>Usa o Click ID inicial</small>
                <Handle type="source" position={Position.Bottom} />
            </>
        )),
        action_city: memo(({ data }) => (
            <>
                <Handle type="target" position={Position.Top} />
                <div><strong>📍 Consultar Cidade (Ação)</strong></div>
                <p style={{fontSize: 12, color: '#555'}}>Usa o Click ID inicial</p>
                <Handle type="source" position={Position.Bottom} />
            </>
        )),
    };
    
    function FlowCanvas({ flow, onBack }) {
      const reactFlowWrapper = useRef(null);
      const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
      const [edges, setEdges, onEdgesChange] = useEdgesState([]);
      const [selectedNode, setSelectedNode] = useState(null);
      const [reactFlowInstance, setReactFlowInstance] = useState(null);
      
      useEffect(() => {
        if(flow && flow.nodes) {
            const flowContent = typeof flow.nodes === 'string' ? JSON.parse(flow.nodes) : flow.nodes;
            setNodes(flowContent.nodes || initialNodes);
            setEdges(flowContent.edges || []);
        }
      }, [flow]);

      const onConnect = useCallback((params) => setEdges((eds) => addEdge({ ...params, type: 'smoothstep', animated: true }, eds)), []);
      
      const onNodeClick = useCallback((_, node) => {
          if (node.type !== 'trigger') {
              setSelectedNode(node);
          }
      }, []);
      
      const onNodesChangeFiltered = useCallback((changes) => {
          const nextChanges = changes.filter(change => {
              if (change.type === 'remove') {
                  const nodeToRemove = nodes.find(n => n.id === change.id);
                  return nodeToRemove && nodeToRemove.type !== 'trigger';
              }
              return true;
          });
          onNodesChange(nextChanges);
      }, [nodes, onNodesChange]);
      
      const onDragOver = useCallback((event) => {
        event.preventDefault();
        event.dataTransfer.dropEffect = 'move';
      }, []);
      
      const onDrop = useCallback((event) => {
          event.preventDefault();
          const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
          const type = event.dataTransfer.getData('application/reactflow');
          if (typeof type === 'undefined' || !type) return;
          
          const position = reactFlowInstance.project({
            x: event.clientX - reactFlowBounds.left,
            y: event.clientY - reactFlowBounds.top,
          });
          const newNode = {
              id: `${type}-${Date.now()}`,
              type,
              position,
              data: { label: type },
          };
          setNodes((nds) => nds.concat(newNode));
      }, [reactFlowInstance]);

      const handleSave = async () => {
          try {
              await api.put(`/flows/${flow.id}`, { name: flow.name, nodes: JSON.stringify({ nodes, edges }) });
              alert("Fluxo salvo com sucesso!");
          } catch(error) { alert("Erro ao salvar o fluxo."); }
      };

      return (
          <div className="flow-editor-page">
            <div className="flow-header">
              <h3>Editando: {flow.name}</h3>
              <div>
                <button className="btn btn-secondary" style={{ marginRight: '0.5rem' }} onClick={onBack}>Voltar</button>
                <button className="btn btn-primary" onClick={handleSave}>Salvar Fluxo</button>
              </div>
            </div>
            <div className="reactflow-wrapper" ref={reactFlowWrapper} onDrop={onDrop} onDragOver={onDragOver}>
                <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChangeFiltered} onEdgesChange={onEdgesChange} onConnect={onConnect} onNodeClick={onNodeClick} onInit={setReactFlowInstance} nodeTypes={nodeTypes} fitView>
                    <Background />
                    <Controls />
                </ReactFlow>
                {selectedNode && <EditorPanel selectedNode={selectedNode} setNodes={setNodes} setSelectedNode={setSelectedNode} />}
            </div>
          </div>
      );
    }
    
    function FlowEditorPage({ flow, onBack }) {
        if (!flow) return <div>Carregando fluxo...</div>;
        return (
            <div className="flow-editor-container">
                <div className="flow-sidebar">
                    <h3>Componentes</h3>
                    <div className="node-button" onDragStart={(e) => e.dataTransfer.setData('application/reactflow', 'message')} draggable>💬 Mensagem</div>
                    <h3>Ações</h3>
                    <div className="node-button" onDragStart={(e) => e.dataTransfer.setData('application/reactflow', 'action_pix')} draggable>💳 Gerar PIX (Ação)</div>
                    <div className="node-button" onDragStart={(e) => e.dataTransfer.setData('application/reactflow', 'action_city')} draggable>📍 Consultar Cidade (Ação)</div>
                </div>
                <ReactFlowProvider>
                    <FlowCanvas flow={flow} onBack={onBack} />
                </ReactFlowProvider>
            </div>
        );
    }

    function EditorPanel({ selectedNode, setNodes, setSelectedNode }) {
        const [nodeData, setNodeData] = useState(selectedNode.data);
        
        useEffect(() => { setNodeData(selectedNode.data) }, [selectedNode]);

        const handleChange = (e) => {
            const { name, value } = e.target;
            setNodeData(prev => ({...prev, [name]: name === 'valueInCents' ? parseInt(value) : value }));
        };

        const onSave = () => {
            setNodes(nds => nds.map(n => n.id === selectedNode.id ? {...n, data: nodeData} : n));
            setSelectedNode(null);
        };
        
        const onDelete = () => {
            setNodes(nds => nds.filter(n => n.id !== selectedNode.id));
            setSelectedNode(null);
        };

        return (
            <div className="editor-panel">
                <h3 style={{marginBottom: '1rem'}}>Editar Nó: {selectedNode.data.label || selectedNode.type}</h3>
                <div className="form-group">
                    <label>Rótulo (para sua referência)</label>
                    <input name="label" className="form-input" value={nodeData.label || ''} onChange={handleChange} />
                </div>
                {selectedNode.type === 'message' && (
                    <div className="form-group">
                        <label>Texto da Mensagem</label>
                        <textarea name="text" className="form-textarea" rows="5" value={nodeData.text || ''} onChange={handleChange} />
                    </div>
                )}
                {selectedNode.type === 'action_pix' && (
                    <div className="form-group">
                        <label>Valor em Centavos</label>
                        <input name="valueInCents" type="number" className="form-input" value={nodeData.valueInCents || 0} onChange={handleChange} />
                    </div>
                )}
                <button className="btn btn-primary" onClick={onSave}>Salvar</button>
                <button className="btn btn-secondary" style={{marginLeft: '0.5rem'}} onClick={() => setSelectedNode(null)}>Fechar</button>
                { selectedNode.type !== 'trigger' && <button className="btn btn-danger" style={{marginTop: '1rem', width: '100%'}} onClick={onDelete}>Excluir Nó</button> }
            </div>
        );
    }
    
    function LoginScreen({ onLogin }) {
        const [email, setEmail] = useState('');
        const [password, setPassword] = useState('');
        const handleSubmit = async (e) => {
            e.preventDefault();
            try {
                const response = await axios.post(`${API_BASE_URL}/sellers/login`, { email, password });
                onLogin(response.data.token);
            } catch (error) {
                alert('Falha no login: ' + (error.response?.data?.message || 'Erro de conexão'));
            }
        };
        return (
            <div className="login-overlay">
                <div className="login-box">
                    <h2 style={{textAlign: 'center', marginBottom: '1.5rem'}}>Login Hotbot</h2>
                    <form onSubmit={handleSubmit}>
                       <div className="form-group">
                           <input className="form-input" type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" required />
                       </div>
                       <div className="form-group">
                           <input className="form-input" type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Senha" required />
                       </div>
                        <button className="btn btn-primary" type="submit" style={{width: '100%'}}>Entrar</button>
                    </form>
                </div>
            </div>
        );
    }

    // --- Render App ---
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
