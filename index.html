<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plataforma de Automação para Telegram</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .bg-dots {
            background-size: 40px 40px;
            background-image: radial-gradient(circle, #e5e7eb 1px, rgba(0,0,0,0) 1px);
        }
        .editor-panel {
            animation: slideIn 0.3s ease-out forwards;
        }
        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }
    </style>
    
    <!-- Scripts movidos para o head para garantir o carregamento antes do corpo da página -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/lucide-react@latest/dist/lucide-react.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        // Aguarda o DOM estar completamente carregado antes de executar o React
        document.addEventListener('DOMContentLoaded', () => {
            const { useState, useCallback, useRef, useEffect } = React;
            const { MessageSquare, Save, Clock, Trash2, Bot, Image, FileAudio, Video, GitBranchPlus, MapPin, DollarSign, BadgeCheck, ExternalLink, ZoomIn, ZoomOut, Settings, BotMessageSquare, MessageCircle, Plus, Edit, ArrowLeft, Send, Copy, LogOut } = lucide;

            // --- CONFIGURAÇÃO DA API ---
            const API_BASE_URL = 'https://novaapi-one.vercel.app'; 

            // --- API Helper ---
            const api = {
                async get(endpoint, token) {
                    const response = await fetch(`${API_BASE_URL}/api/platform${endpoint}`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (!response.ok) throw new Error('A resposta da rede não foi OK.');
                    return response.json();
                },
                async post(endpoint, body, token) {
                    const response = await fetch(`${API_BASE_URL}/api/platform${endpoint}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(body)
                    });
                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.message || 'A resposta da rede não foi OK.');
                    }
                    return response.json();
                },
                async put(endpoint, body, token) {
                     const response = await fetch(`${API_BASE_URL}/api/platform${endpoint}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify(body)
                    });
                    if (!response.ok) throw new Error('A resposta da rede não foi OK.');
                    return response.json();
                },
                async delete(endpoint, token) {
                    const response = await fetch(`${API_BASE_URL}/api/platform${endpoint}`, {
                        method: 'DELETE',
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (!response.ok) throw new Error('A resposta da rede não foi OK.');
                    return response;
                }
            };

            const createInitialFlow = (id, name, botId) => ({
                id,
                name,
                botId,
                nodes: [{ 
                    id: 1, type: 'start', content: 'Início do Fluxo', 
                    position: { x: 50, y: 150 }, 
                    outputs: [{ id: 'out', nextStepId: null }] 
                }]
            });

            // --- COMPONENTES HELPER ---
            const SidebarButton = ({ icon, label, onClick }) => (
                <button onClick={onClick} className="w-full flex items-center p-3 rounded-lg bg-gray-50 hover:bg-indigo-100 text-gray-600 hover:text-indigo-600 transition-all duration-200 mb-2">
                    {React.createElement(icon, { className: "w-5 h-5 mr-3" })}
                    <span>{label}</span>
                </button>
            );

            const Controls = ({ onZoomIn, onZoomOut }) => (
                <div className="absolute bottom-4 right-4 bg-white rounded-lg shadow-md border border-gray-200 flex z-10">
                    <button onClick={onZoomOut} className="p-2 text-gray-600 hover:bg-gray-100 border-r border-gray-200">-</button>
                    <button onClick={onZoomIn} className="p-2 text-gray-600 hover:bg-gray-100">+</button>
                </div>
            );

            const Connections = ({ nodes, connectionPreview }) => {
                Connections.getOutputYOffset = (node, outputId) => {
                    if (node.type === 'contentBlock' && node.replySettings?.awaitsReply) {
                        return outputId === 'onTimeout' ? 55 : 85;
                    }
                    if ((node.outputs || []).length > 1) {
                        return outputId === 'success' || outputId === 'paid' ? 55 : 85;
                    }
                    return 45;
                };
                
                return (
                    <svg className="absolute w-full h-full pointer-events-none overflow-visible">
                        <defs>
                            <marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#9ca3af" />
                            </marker>
                             <marker id="arrow-red" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#f87171" />
                            </marker>
                             <marker id="arrow-green" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                                <path d="M 0 0 L 10 5 L 0 10 z" fill="#4ade80" />
                            </marker>
                        </defs>
                        <g>
                            {(nodes || []).map(node => {
                                let connections = [];
                                if (node.type === 'contentBlock' && node.replySettings?.awaitsReply) {
                                    if(node.replySettings.onReplyNextStepId) connections.push({ id: 'onReply', nextStepId: node.replySettings.onReplyNextStepId });
                                    if(node.replySettings.onTimeoutNextStepId) connections.push({ id: 'onTimeout', nextStepId: node.replySettings.onTimeoutNextStepId });
                                } else {
                                    connections = node.outputs || [];
                                }

                                return (connections || []).map(output => {
                                    if (!output.nextStepId) return null;
                                    const targetNode = nodes.find(n => n.id === output.nextStepId);
                                    if (!targetNode) return null;
                                    
                                    const yOffset = Connections.getOutputYOffset(node, output.id);
                                    const isTimeout = output.id === 'onTimeout';
                                    const isSuccess = output.id === 'onReply';
                                    
                                    let strokeColor = "#9ca3af";
                                    let marker = "url(#arrow)";

                                    if(isTimeout) {
                                        strokeColor = "#f87171";
                                        marker = "url(#arrow-red)";
                                    } else if (isSuccess) {
                                        strokeColor = "#4ade80";
                                         marker = "url(#arrow-green)";
                                    }

                                    const startPos = { x: node.position.x + 288, y: node.position.y + yOffset };
                                    const endPos = { x: targetNode.position.x, y: targetNode.position.y + 45 }; 
                                    const path = `M ${startPos.x} ${startPos.y} C ${startPos.x + 60} ${startPos.y}, ${endPos.x - 60} ${endPos.y}, ${endPos.x} ${endPos.y}`;
                                    
                                    return <path key={`${node.id}-${output.id}`} d={path} stroke={strokeColor} strokeWidth="2" fill="none" markerEnd={marker} strokeDasharray={isTimeout ? "5 5" : "none"} />;
                                });
                            })}
                            {connectionPreview && (
                                <path 
                                    d={`M ${connectionPreview.startPos.x} ${connectionPreview.startPos.y} C ${connectionPreview.startPos.x + 60} ${connectionPreview.startPos.y}, ${connectionPreview.endPos.x - 60} ${connectionPreview.endPos.y}, ${connectionPreview.endPos.x} ${connectionPreview.endPos.y}`}
                                    stroke="#6366f1" 
                                    strokeWidth="2"
                                    strokeDasharray="5 5"
                                    fill="none" 
                                />
                            )}
                        </g>
                    </svg>
                );
            };

            const ActionEditor = ({ action, onUpdate, onRemove }) => {
                const renderActionFields = () => {
                    switch (action.type) {
                        case 'text':
                            return <textarea className="w-full p-2 border rounded-md text-sm" rows="3" value={action.content || ''} onChange={(e) => onUpdate(action.id, { content: e.target.value })} />;
                        case 'image': case 'audio': case 'video':
                            return <input type="text" className="w-full p-2 border rounded-md text-sm" placeholder={`URL do ${action.type}`} value={action.url || ''} onChange={(e) => onUpdate(action.id, { url: e.target.value })} />;
                        case 'delay':
                            return <input type="number" className="w-full p-2 border rounded-md text-sm" placeholder="Segundos" value={action.delaySeconds || 0} onChange={(e) => onUpdate(action.id, { delaySeconds: parseInt(e.target.value, 10) || 0 })} />;
                        default: return null;
                    }
                };
                return (
                    <div className="p-2 border rounded-md bg-gray-50">
                        <div className="flex justify-between items-center mb-2">
                            <span className="text-xs font-bold uppercase text-gray-500">{action.type}</span>
                            <button onClick={() => onRemove(action.id)} className="text-red-400 hover:text-red-600"><Trash2 size={14} /></button>
                        </div>
                        {renderActionFields()}
                    </div>
                );
            };

            const UrlButtonEditor = ({ button, onUpdate, onRemove }) => {
                const [label, setLabel] = useState(button.label);
                const [url, setUrl] = useState(button.url);

                useEffect(() => {
                    onUpdate({ ...button, label, url });
                }, [label, url]);

                return (
                    <div className="p-2 border rounded-md mb-2 bg-gray-50">
                        <input type="text" value={label} onChange={e => setLabel(e.target.value)} className="w-full p-1 border rounded-md mb-2" placeholder="Texto do Botão" />
                        <input type="text" value={url} onChange={e => setUrl(e.target.value)} className="w-full p-1 border rounded-md" placeholder="https://exemplo.com" />
                        <button onClick={() => onRemove(button.id)} className="text-xs text-red-500 hover:text-red-700 mt-1">Remover</button>
                    </div>
                );
            };

            const EditorPanel = ({ node, allFlows, onClose, onUpdate, onDelete }) => {
                const [localNode, setLocalNode] = useState(JSON.parse(JSON.stringify(node)));

                const handleSave = () => {
                    onUpdate(node.id, localNode);
                    onClose();
                };

                const updateLocalNode = (data) => setLocalNode(prev => ({...prev, ...data}));
                const updateReplySettings = (data) => {
                    const currentSettings = localNode.replySettings || { awaitsReply: false, timeoutSeconds: 300 };
                    setLocalNode(prev => ({ ...prev, replySettings: { ...currentSettings, ...data } }));
                };
                
                const updateAction = (actionId, data) => {
                    updateLocalNode({ actions: (localNode.actions || []).map(a => a.id === actionId ? {...a, ...data} : a) });
                };

                const addAction = (type) => {
                    if ((localNode.actions || []).length >= 10) {
                        alert("Você pode adicionar no máximo 10 ações por bloco.");
                        return;
                    }
                    let action;
                    switch(type) {
                        case 'image': action = { id: `act_${Date.now()}`, type: 'image', url: '' }; break;
                        case 'audio': action = { id: `act_${Date.now()}`, type: 'audio', url: '' }; break;
                        case 'video': action = { id: `act_${Date.now()}`, type: 'video', url: '' }; break;
                        case 'delay': action = { id: `act_${Date.now()}`, type: 'delay', delaySeconds: 3 }; break;
                        default: action = { id: `act_${Date.now()}`, type: 'text', content: '' };
                    }
                    updateLocalNode({ actions: [...(localNode.actions || []), action] });
                };
                
                const removeAction = (actionId) => {
                    updateLocalNode({ actions: (localNode.actions || []).filter(a => a.id !== actionId) });
                };

                const addOrUpdateUrlButton = (button) => {
                    const buttons = localNode.urlButtons || [];
                    const exists = buttons.find(b => b.id === button.id);
                    if (exists) {
                        updateLocalNode({ urlButtons: buttons.map(b => b.id === button.id ? button : b) });
                    } else {
                        updateLocalNode({ urlButtons: [...buttons, button] });
                    }
                };

                const removeUrlButton = (buttonId) => {
                    updateLocalNode({ urlButtons: (localNode.urlButtons || []).filter(b => b.id !== buttonId) });
                };

                const renderEditorContent = () => {
                    switch (localNode.type) {
                        case 'contentBlock':
                            return (
                                <>
                                    <h3 className="text-sm font-semibold mb-2">Ações no Bloco</h3>
                                    <div className="space-y-2">
                                        {(localNode.actions || []).map(act => <ActionEditor key={act.id} action={act} onUpdate={updateAction} onRemove={removeAction} />)}
                                    </div>
                                    <div className="mt-4 p-2 border-t text-sm">
                                        <h4 className="font-semibold mb-2">Adicionar Ação</h4>
                                        <div className="grid grid-cols-2 gap-2">
                                            <button onClick={() => addAction('text')} className="text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Texto</button>
                                            <button onClick={() => addAction('delay')} className="text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Atraso</button>
                                            <button onClick={() => addAction('image')} className="text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Imagem</button>
                                            <button onClick={() => addAction('audio')} className="text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Áudio</button>
                                            <button onClick={() => addAction('video')} className="text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Vídeo</button>
                                        </div>
                                    </div>
                                     <div className="mt-4 pt-4 border-t text-sm">
                                        <label className="flex items-center space-x-2 mb-2">
                                            <input type="checkbox" checked={localNode.replySettings?.awaitsReply || false} onChange={(e) => updateReplySettings({ awaitsReply: e.target.checked })} />
                                            <span className="font-semibold">Aguardar resposta do cliente?</span>
                                        </label>

                                         { localNode.replySettings?.awaitsReply ? (
                                            <div className="pl-2 border-l-2">
                                                <label className="block text-xs text-gray-500 mb-1">Se não responder em (minutos):</label>
                                                <input type="number" min="1" className="w-full p-1 border rounded-md mb-2 text-sm" value={(localNode.replySettings.timeoutSeconds || 0) / 60} onChange={(e) => updateReplySettings({ timeoutSeconds: parseInt(e.target.value, 10) * 60 || 0 })} />
                                                <p className="text-xs text-gray-500">Conecte as saídas "SE RESPONDER" e "SE NÃO RESPONDER" no canvas.</p>
                                            </div>
                                         ) : (
                                            <>
                                                <h3 className="text-sm font-semibold mt-2 mb-2">Botões (abrir site)</h3>
                                                {(localNode.urlButtons || []).map(btn => <UrlButtonEditor key={btn.id} button={btn} onUpdate={addOrUpdateUrlButton} onRemove={removeUrlButton} />)}
                                                <button onClick={() => addOrUpdateUrlButton({ id: `btn_${Date.now()}`, label: 'Novo Botão', url: '' })} className="mt-2 text-indigo-600 hover:text-indigo-800 text-sm">+ Adicionar Botão</button>
                                            </>
                                         )}
                                    </div>
                                </>
                            );
                        case 'redirectFlow':
                             return (
                                 <>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Redirecionar para o Fluxo:</label>
                                    <select
                                        className="w-full p-2 border rounded-md"
                                        value={localNode.targetFlowId || ''}
                                        onChange={(e) => updateLocalNode({ targetFlowId: e.target.value, content: `Enviar para fluxo: ${e.target.options[e.target.selectedIndex].text}` })}
                                    >
                                        <option value="">Selecione um fluxo...</option>
                                        {allFlows.map(f => <option key={f.id} value={f.id}>{f.name}</option>)}
                                    </select>
                                 </>
                             );
                        case 'queryClickIdCity':
                             return (
                                <>
                                   <label className="block text-sm font-medium text-gray-700 mb-2">Salvar cidade na variável</label>
                                   <input type="text" className="w-full p-2 border rounded-md" value={localNode.cityVar || ''} onChange={(e) => updateLocalNode({ cityVar: e.target.value, content: `Salva cidade em {{${e.target.value}}}` })} />
                                </>
                             );
                        case 'generatePix':
                            return (
                                <>
                                    <label className="block text-sm font-medium text-gray-700 mb-2">Valor do PIX (em centavos)</label>
                                    <input type="number" className="w-full p-2 border rounded-md" value={localNode.valueInCents || 0} onChange={(e) => updateLocalNode({ valueInCents: parseInt(e.target.value, 10) || 0, content: `Gerar PIX de R$ ${(parseInt(e.target.value, 10) / 100 || 0).toFixed(2)}` })} />
                                    <label className="block text-sm font-medium text-gray-700 mt-4 mb-2">Mensagem para o cliente</label>
                                    <textarea className="w-full p-2 border rounded-md text-sm" rows="4" value={localNode.messageTemplate || ''} onChange={(e) => updateLocalNode({ messageTemplate: e.target.value })} />
                                    <p className="text-xs text-gray-500 mt-1">Use <code>{"{{pix_code}}"}</code> onde o PIX deve aparecer. Um botão "Copiar" será adicionado automaticamente.</p>
                                </>
                            );
                         case 'queryPixStatus':
                            return ( <p className="text-sm text-gray-600">Esta ação irá verificar o status do último PIX gerado para o cliente.</p> );
                        default: return <p>Este passo não pode ser editado.</p>;
                    }
                };

                return (
                     <div className="editor-panel absolute top-0 right-0 w-96 h-full bg-white shadow-2xl border-l border-gray-200 p-4 z-20 flex flex-col">
                        <div className="flex justify-between items-center mb-4">
                            <h2 className="text-lg font-bold capitalize">Editar: {localNode.type.replace(/([A-Z])/g, ' $1').trim()}</h2>
                            <button onClick={onClose} className="p-1 rounded-full text-2xl leading-none hover:bg-gray-200">&times;</button>
                        </div>
                        <div className="flex-1 overflow-y-auto pr-2">{renderEditorContent()}</div>
                        <div className="mt-4 pt-4 border-t flex justify-between">
                            <button onClick={() => onDelete(localNode.id)} disabled={localNode.type === 'start'} className="p-2 text-red-600 hover:bg-red-100 rounded-md disabled:opacity-50 disabled:cursor-not-allowed">
                                <Trash2 />
                            </button>
                             <button onClick={handleSave} className="py-2 px-4 bg-indigo-600 text-white rounded-md hover:bg-indigo-700">Salvar Alterações</button>
                        </div>
                    </div>
                );
            };

            // ############################################################################
            // --- COMPONENTES DE TELAS ---
            // ############################################################################

            const SettingsView = ({ bots, setBots, token }) => {
                const [tokenInput, setTokenInput] = useState('');
                const [botName, setBotName] = useState('');
                const [isLoading, setIsLoading] = useState(false);
                const [error, setError] = useState('');

                const handleAddBot = async () => {
                    if (!tokenInput || !botName) {
                        setError('Nome e token são obrigatórios.');
                        return;
                    }
                    setIsLoading(true);
                    setError('');
                    
                    try {
                        const newBot = await api.post('/bots', { name: botName, token: tokenInput }, token);
                        setBots(prev => [newBot, ...prev]);
                        setTokenInput('');
                        setBotName('');
                    } catch(err) {
                        setError(err.message || "Erro ao conectar bot.");
                    } finally {
                        setIsLoading(false);
                    }
                };
                
                const handleDeleteBot = async (botId) => {
                    if(window.confirm("Tem certeza que quer remover este bot?")){
                        try {
                            await api.delete(`/bots/${botId}`, token);
                            setBots(prev => prev.filter(b => b.id !== botId));
                        } catch(err) {
                            alert("Falha ao remover bot.");
                        }
                    }
                }

                return (
                    <div className="p-8 max-w-4xl mx-auto">
                        <h1 className="text-3xl font-bold text-gray-800 mb-6">Configurações de Bots</h1>
                        <div className="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-8">
                            <h2 className="text-xl font-semibold mb-4">Adicionar Novo Bot</h2>
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                                 <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Nome do Bot</label>
                                    <input type="text" value={botName} onChange={(e) => setBotName(e.target.value)} placeholder="Ex: Bot de Vendas" className="w-full p-2 border rounded-md" disabled={isLoading}/>
                                </div>
                                <div className="md:col-span-2">
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Token do Bot (do BotFather)</label>
                                    <input type="text" value={tokenInput} onChange={(e) => setTokenInput(e.target.value)} placeholder="Ex: 123456:ABC-DEF1234..." className="w-full p-2 border rounded-md" disabled={isLoading}/>
                                </div>
                            </div>
                            <div className="mt-4 flex justify-end">
                                <button onClick={handleAddBot} className="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 disabled:bg-indigo-300" disabled={isLoading}>
                                    {isLoading ? 'Adicionando...' : 'Adicionar Bot'}
                                </button>
                            </div>
                            {error && <p className="text-red-500 text-sm mt-2">{error}</p>}
                        </div>

                        <h2 className="text-2xl font-bold text-gray-800 mb-4">Bots Conectados</h2>
                        <div className="space-y-4">
                            {bots.map(bot => (
                                <div key={bot.id} className="bg-white p-4 rounded-lg shadow-sm border flex justify-between items-center">
                                    <div>
                                        <p className="font-bold text-lg">{bot.name}</p>
                                        <p className="text-sm text-gray-500">@{bot.username}</p>
                                    </div>
                                    <button onClick={() => handleDeleteBot(bot.id)} className="p-2 text-gray-400 hover:text-red-500"><Trash2 size={16}/></button>
                                </div>
                            ))}
                        </div>
                    </div>
                );
            };

            const BroadcastsView = ({ bots }) => {
                const [broadcasts, setBroadcasts] = useState([]);
                const [selectedBotId, setSelectedBotId] = useState('all');
                const [actions, setActions] = useState([]);
                const [broadcastName, setBroadcastName] = useState('');
                
                useEffect(() => {
                    setBroadcasts([
                        { id: 1, name: 'Promoção da Semana', actions: [{id: 1, type: 'text', content: 'Olá! Temos uma nova promoção esta semana.'}], botId: 1, sentAt: '2025-09-21 10:30' },
                        { id: 2, name: 'Aviso de Manutenção', actions: [{id: 1, type: 'text', content: 'Nosso suporte estará offline por 1 hora.'}], botId: 2, sentAt: '2025-09-20 15:00' },
                    ]);
                }, []);

                const handleSend = () => {
                    if(!actions.length) {
                        alert("Por favor, adicione pelo menos uma ação de conteúdo.");
                        return;
                    }
                    const target = selectedBotId === 'all' ? 'todos os bots' : bots.find(b => b.id === parseInt(selectedBotId))?.name;
                    const newBroadcast = {
                        id: broadcasts.length > 0 ? Math.max(...broadcasts.map(b => b.id)) + 1 : 1,
                        name: broadcastName || "Disparo sem nome",
                        actions,
                        botId: selectedBotId === 'all' ? null : parseInt(selectedBotId),
                        sentAt: new Date().toLocaleString()
                    };
                    setBroadcasts(prev => [newBroadcast, ...prev]);
                    alert(`Disparo "${newBroadcast.name}" enviado para ${target}!`);
                    setActions([]);
                    setBroadcastName('');
                };

                const handleReuse = (broadcast) => {
                    setActions(broadcast.actions);
                    setBroadcastName(`Cópia de ${broadcast.name}`);
                }

                const addAction = (type) => {
                    if (actions.length >= 10) { alert("Máximo de 10 ações por disparo."); return; }
                    let action;
                    switch(type) {
                        case 'image': action = { id: `act_${Date.now()}`, type: 'image', url: '' }; break;
                        case 'delay': action = { id: `act_${Date.now()}`, type: 'delay', delaySeconds: 3 }; break;
                        default: action = { id: `act_${Date.now()}`, type: 'text', content: '' };
                    }
                    setActions(prev => [...prev, action]);
                };
                
                const updateAction = (actionId, data) => {
                    setActions(prev => prev.map(a => a.id === actionId ? {...a, ...data} : a));
                };

                const removeAction = (actionId) => {
                    setActions(prev => prev.filter(a => a.id !== actionId));
                };
                
                return (
                    <div className="p-8 max-w-4xl mx-auto h-full flex flex-col">
                         <h1 className="text-3xl font-bold text-gray-800 mb-6">Disparos em Massa</h1>
                         <div className="bg-white p-6 rounded-lg shadow-md border border-gray-200 mb-8">
                             <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                 <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Nome do Disparo (interno)</label>
                                    <input type="text" value={broadcastName} onChange={e => setBroadcastName(e.target.value)} className="w-full p-2 border rounded-md" />
                                 </div>
                                 <div>
                                    <label className="block text-sm font-medium text-gray-700 mb-1">Enviar para:</label>
                                    <select value={selectedBotId} onChange={e => setSelectedBotId(e.target.value)} className="w-full p-2 border rounded-md">
                                        <option value="all">Todos os Bots</option>
                                        {bots.map(bot => <option key={bot.id} value={bot.id}>{bot.name}</option>)}
                                    </select>
                                 </div>
                             </div>
                             <div className="border-t pt-4">
                                <h3 className="text-lg font-semibold mb-2">Conteúdo do Disparo</h3>
                                <div className="space-y-2 mb-4">
                                    {actions.map(act => <ActionEditor key={act.id} action={act} onUpdate={updateAction} onRemove={removeAction} />)}
                                </div>
                                <div className="flex items-center space-x-2">
                                    <button onClick={() => addAction('text')} className="text-sm text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Texto</button>
                                    <button onClick={() => addAction('delay')} className="text-sm text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Atraso</button>
                                    <button onClick={() => addAction('image')} className="text-sm text-indigo-600 hover:bg-indigo-50 p-2 rounded-md">+ Imagem</button>
                                </div>
                             </div>
                             <div className="mt-6 flex justify-end">
                                <button onClick={handleSend} className="bg-indigo-600 text-white px-6 py-2 rounded-md hover:bg-indigo-700 flex items-center">
                                    <Send size={16} className="mr-2"/>
                                    Enviar Disparo
                                </button>
                             </div>
                         </div>
                         <h2 className="text-2xl font-bold text-gray-800 mb-4">Histórico de Disparos</h2>
                         <div className="flex-1 bg-white rounded-lg shadow-sm border overflow-y-auto">
                            <ul className="divide-y divide-gray-200">
                                {broadcasts.map(b => {
                                    const botName = b.botId ? bots.find(bot => bot.id === b.botId)?.name : 'Todos os Bots';
                                    return (
                                    <li key={b.id} className="p-4 flex justify-between items-start">
                                        <div>
                                            <p className="font-semibold text-gray-800">{b.name}</p>
                                            <p className="text-sm text-gray-600 mt-1">"{b.actions[0].content.substring(0, 50)}..."</p>
                                            <p className="text-xs text-gray-500 mt-2">Enviado para <span className="font-semibold">{botName}</span> em {b.sentAt}</p>
                                        </div>
                                        <button onClick={() => handleReuse(b)} className="p-2 text-gray-400 hover:text-indigo-500" title="Reutilizar mensagem">
                                            <Copy size={16}/>
                                        </button>
                                    </li>
                                )})}
                            </ul>
                         </div>
                    </div>
                );
            }

            const LiveChatView = ({ bots }) => {
                const [selectedBotId, setSelectedBotId] = useState('all');
                const conversations = [
                    { id: 1, botId: 1, name: 'João Silva', lastMessage: 'Olá, gostaria de saber mais...', time: '10:05', unread: 2 },
                    { id: 2, botId: 2, name: 'Maria Pereira', lastMessage: 'Obrigada!', time: '09:48', unread: 0 },
                    { id: 3, botId: 1, name: 'Carlos Souza', lastMessage: 'Qual o valor?', time: 'Ontem', unread: 0 },
                ];
                const activeChat = { name: 'João Silva', messages: [ { id: 1, sender: 'user', text: 'Olá, gostaria de saber mais sobre o produto.' }, { id: 2, sender: 'bot', text: 'Claro! Qual sua dúvida?' }, ] };
                const filteredConversations = selectedBotId === 'all' ? conversations : conversations.filter(c => c.botId === parseInt(selectedBotId));

                return (
                    <div className="flex h-full bg-white">
                        <aside className="w-1/3 border-r border-gray-200 h-full flex flex-col">
                             <div className="p-4 border-b">
                                <h2 className="text-xl font-bold mb-4">Conversas</h2>
                                <select value={selectedBotId} onChange={e => setSelectedBotId(e.target.value)} className="w-full p-2 border rounded-md">
                                    <option value="all">Todos os Bots</option>
                                    {bots.map(bot => <option key={bot.id} value={bot.id}>{bot.name}</option>)}
                                </select>
                            </div>
                            <ul className="overflow-y-auto">
                                {filteredConversations.map(conv => (
                                    <li key={conv.id} className={`p-4 border-b cursor-pointer hover:bg-gray-50 ${conv.id === 1 ? 'bg-indigo-50' : ''}`}>
                                        <div className="flex justify-between items-center">
                                            <span className="font-bold">{conv.name}</span>
                                            <span className="text-xs text-gray-500">{conv.time}</span>
                                        </div>
                                        <div className="flex justify-between items-center mt-1">
                                            <p className="text-sm text-gray-600 truncate">{conv.lastMessage}</p>
                                            {conv.unread > 0 && <span className="bg-indigo-600 text-white text-xs rounded-full px-2 py-1">{conv.unread}</span>}
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        </aside>
                        <main className="w-2/3 h-full flex flex-col">
                            <header className="p-4 border-b flex items-center">
                                <h2 className="text-xl font-bold">{activeChat.name}</h2>
                            </header>
                            <div className="flex-1 p-4 overflow-y-auto bg-gray-50">
                                {activeChat.messages.map(msg => (
                                    <div key={msg.id} className={`flex mb-4 ${msg.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
                                        <div className={`p-3 rounded-lg max-w-md ${msg.sender === 'user' ? 'bg-indigo-600 text-white' : 'bg-gray-200 text-gray-800'}`}>
                                            {msg.text}
                                        </div>
                                    </div>
                                ))}
                            </div>
                             <footer className="p-4 border-t">
                                <input type="text" placeholder="Digite sua mensagem..." className="w-full p-2 border rounded-md" />
                            </footer>
                        </main>
                    </div>
                );
            };

            const FlowsView = ({ flows, bots, onEdit, onCreate, onDelete }) => {
                const [selectedBotId, setSelectedBotId] = useState(bots[0]?.id.toString() || 'all');

                const filteredFlows = selectedBotId === 'all' ? flows : flows.filter(f => f.botId === parseInt(selectedBotId));

                return (
                    <div className="p-8">
                        <div className="flex justify-between items-center mb-6">
                            <h1 className="text-3xl font-bold text-gray-800">Seus Fluxos</h1>
                             <div className="flex items-center space-x-4">
                                <select value={selectedBotId} onChange={e => setSelectedBotId(e.target.value)} className="p-2 border rounded-md bg-white">
                                    <option value="all">Todos os Bots</option>
                                    {bots.map(bot => <option key={bot.id} value={bot.id}>{bot.name}</option>)}
                                </select>
                                <button onClick={() => onCreate(selectedBotId === 'all' ? null : parseInt(selectedBotId))} className="flex items-center bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">
                                    <Plus size={16} className="mr-2" />
                                    Criar Novo Fluxo
                                </button>
                             </div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {filteredFlows.map(flow => {
                                const botName = bots.find(b => b.id === flow.botId)?.name || 'Bot desconhecido';
                                return (
                                    <div key={flow.id} className="bg-white p-6 rounded-lg shadow-md border border-gray-200 flex flex-col justify-between">
                                        <div>
                                            <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded-full">{botName}</span>
                                            <h2 className="text-xl font-semibold my-2">{flow.name}</h2>
                                            <p className="text-sm text-gray-500">{(flow.nodes || []).length} blocos</p>
                                        </div>
                                        <div className="flex items-center justify-end space-x-2 mt-4">
                                            <button onClick={() => onDelete(flow.id)} className="p-2 text-gray-400 hover:text-red-500"><Trash2 size={16}/></button>
                                            <button onClick={() => onEdit(flow.id)} className="flex items-center bg-gray-100 text-gray-700 px-3 py-1 rounded-md hover:bg-gray-200">
                                                <Edit size={14} className="mr-2" />
                                                Editar
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };

            const LoginView = ({ onLogin }) => {
                const [email, setEmail] = useState('');
                const [password, setPassword] = useState('');
                const [error, setError] = useState('');
                const [isLoading, setIsLoading] = useState(false);

                const handleSubmit = async (e) => {
                    e.preventDefault();
                    setIsLoading(true);
                    setError('');
                    try {
                        const response = await fetch(`${API_BASE_URL}/api/sellers/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ email, password })
                        });
                        const data = await response.json();
                        if (!response.ok) {
                            throw new Error(data.message || 'Erro ao fazer login.');
                        }
                        onLogin(data.token);
                    } catch (err) {
                        setError(err.message);
                    } finally {
                        setIsLoading(false);
                    }
                };
                
                return (
                    <div className="flex items-center justify-center h-screen bg-gray-100">
                        <div className="p-8 bg-white rounded-lg shadow-md w-full max-w-sm">
                            <h1 className="text-2xl font-bold text-center mb-6">Login</h1>
                            <form onSubmit={handleSubmit}>
                                <div className="mb-4">
                                    <label className="block mb-1">Email</label>
                                    <input type="email" value={email} onChange={e => setEmail(e.target.value)} className="w-full p-2 border rounded" required />
                                </div>
                                <div className="mb-6">
                                    <label className="block mb-1">Senha</label>
                                    <input type="password" value={password} onChange={e => setPassword(e.target.value)} className="w-full p-2 border rounded" required />
                                </div>
                                {error && <p className="text-red-500 text-sm mb-4">{error}</p>}
                                <button type="submit" className="w-full bg-indigo-600 text-white p-2 rounded hover:bg-indigo-700" disabled={isLoading}>
                                    {isLoading ? 'Entrando...' : 'Entrar'}
                                </button>
                            </form>
                        </div>
                    </div>
                );
            };


            const App = () => {
                const [token, setToken] = useState(localStorage.getItem('authToken'));
                const [activeTab, setActiveTab] = useState('flows');
                const [bots, setBots] = useState([]);
                const [flows, setFlows] = useState([]);
                const [editingFlowId, setEditingFlowId] = useState(null);
                const [isLoading, setIsLoading] = useState(!!token);

                useEffect(() => {
                    if (token) {
                        setIsLoading(true);
                        const fetchData = async () => {
                            try {
                                const [botsData, flowsData] = await Promise.all([
                                    api.get('/bots', token),
                                    api.get('/flows', token)
                                ]);
                                setBots(botsData);
                                setFlows(flowsData.map(flow => ({...flow, nodes: typeof flow.nodes === 'string' ? JSON.parse(flow.nodes) : flow.nodes})));
                            } catch (error) {
                                console.error("Falha ao buscar dados iniciais", error);
                                handleLogout();
                            } finally {
                                setIsLoading(false);
                            }
                        };
                        fetchData();
                    } else {
                        setIsLoading(false);
                    }
                }, [token]);

                const handleLogin = (newToken) => {
                    localStorage.setItem('authToken', newToken);
                    setToken(newToken);
                };

                const handleLogout = () => {
                    localStorage.removeItem('authToken');
                    setToken(null);
                    setBots([]);
                    setFlows([]);
                };

                const handleCreateFlow = async (botId) => {
                    if(!botId && bots.length > 0) {
                       botId = bots[0].id;
                    }
                    if(!botId && bots.length === 0) {
                        alert("Por favor, crie um bot primeiro na aba de Configurações.");
                        setActiveTab('settings');
                        return;
                    }
                    
                    try {
                        const newFlowData = await api.post('/flows', { name: `Novo Fluxo ${flows.length + 1}`, botId }, token);
                        setFlows(prev => [...prev, {...newFlowData, nodes: typeof newFlowData.nodes === 'string' ? JSON.parse(newFlowData.nodes) : newFlowData.nodes}]);
                        setEditingFlowId(newFlowData.id);
                    } catch (error) {
                        console.error("Falha ao criar fluxo:", error);
                        alert("Erro ao criar fluxo.");
                    }
                };

                const handleSaveFlow = async (flowId, updatedFlowData) => {
                    try {
                        await api.put(`/flows/${flowId}`, updatedFlowData, token);
                        setFlows(prev => prev.map(f => f.id === flowId ? { ...f, ...updatedFlowData } : f));
                        alert("Fluxo salvo com sucesso!");
                    } catch (error) {
                        console.error("Falha ao salvar fluxo:", error);
                        alert("Erro ao salvar fluxo.");
                    }
                };
                
                const handleDeleteFlow = async (flowId) => {
                    if (window.confirm("Tem certeza que deseja excluir este fluxo?")) {
                         try {
                            await api.delete(`/flows/${flowId}`, token);
                            setFlows(prev => prev.filter(f => f.id !== flowId));
                        } catch (error) {
                            console.error("Falha ao excluir fluxo:", error);
                            alert("Erro ao excluir fluxo.");
                        }
                    }
                };

                if (!token) {
                    return <LoginView onLogin={handleLogin} />;
                }

                if (isLoading) {
                    return <div className="flex h-screen items-center justify-center">Carregando Plataforma...</div>;
                }
                
                const renderContent = () => {
                    switch (activeTab) {
                        case 'settings': return <SettingsView bots={bots} setBots={setBots} token={token} />;
                        case 'flows': 
                            const flowToEdit = flows.find(f => f.id === editingFlowId);
                            if (flowToEdit) {
                                const allFlowsForBot = flows.filter(f => f.botId === flowToEdit.botId);
                                return <FlowBuilder flow={flowToEdit} allFlows={allFlowsForBot} onSave={handleSaveFlow} onBack={() => setEditingFlowId(null)} />;
                            }
                            return <FlowsView flows={flows} bots={bots} onEdit={setEditingFlowId} onCreate={handleCreateFlow} onDelete={handleDeleteFlow} />;
                        case 'livechat': return <LiveChatView bots={bots} />;
                        case 'broadcasts': return <BroadcastsView bots={bots} />;
                        default: return <p>Selecione uma aba</p>;
                    }
                };

                return (
                    <div className="flex h-screen bg-gray-100 font-sans">
                        <nav className="w-20 bg-gray-800 text-white flex flex-col items-center p-4 space-y-6">
                            <BotMessageSquare size={32} className="text-indigo-400" />
                            <MainNavItem icon={Settings} label="Config" isActive={activeTab === 'settings'} onClick={() => { setActiveTab('settings'); setEditingFlowId(null); }} />
                            <MainNavItem icon={GitBranchPlus} label="Fluxos" isActive={activeTab === 'flows'} onClick={() => { setActiveTab('flows'); setEditingFlowId(null); }} />
                            <MainNavItem icon={MessageCircle} label="Chat" isActive={activeTab === 'livechat'} onClick={() => { setActiveTab('livechat'); setEditingFlowId(null); }} />
                            <MainNavItem icon={Send} label="Disparos" isActive={activeTab === 'broadcasts'} onClick={() => { setActiveTab('broadcasts'); setEditingFlowId(null); }} />
                            <div className="mt-auto">
                                <MainNavItem icon={LogOut} label="Sair" isActive={false} onClick={handleLogout} />
                            </div>
                        </nav>
                        <div className="flex-1 h-full overflow-hidden">
                            {renderContent()}
                        </div>
                    </div>
                );
            }

            const MainNavItem = ({ icon, label, isActive, onClick }) => (
                <button 
                    onClick={onClick}
                    className={`flex flex-col items-center justify-center w-full h-16 transition-colors duration-200 ${isActive ? 'bg-gray-700 text-white' : 'text-gray-400 hover:bg-gray-700 hover:text-white'}`}
                    title={label}
                >
                    {React.createElement(icon, { size: 24 })}
                    <span className="text-xs mt-1">{label}</span>
                </button>
            );

            ReactDOM.render(React.createElement(App), document.getElementById('root'));
        });
    </script>
</body>
</html>

